<head>
 <link rel="stylesheet" href="style.css">
</head>

<body>
  
<pre>

 Book (russian) : HTTP API and REST
 https://twirl.github.io/The-API-Book/index.ru.html

 https://habr.com/ru/articles/743818/

 https://habr.com/ru/companies/piter/articles/810955/

 https://habr.com/ru/companies/sportmaster_lab/articles/808429/
 
https://florimond.dev/blog/articles/2018/08/restful-api-design-13-best-practices-to-make-your-users-happy/

https://en.wikipedia.org/wiki/Overview_of_RESTful_API_Description_Languages 

https://youtu.be/Z9E7sDhCn5U?list=PLEx5khR4g7PKT9RvuVyQxJLO8CZUJzNMy .  REST beyond obvious

https://github.com/dbohdan/automatic-api/ .  turns your database into a REST/GraphQL API

https://leanpub.com/restful-api-design . Book

https://habr.com/ru/company/piter/blog/472522/ . Book

https://www.portablecto.com/guides/api-development

https://www.manifold.co/blog/graphql-vs-rest-whats-the-advantage

https://www.youtube.com/watch?v=I3loMuHnYqw .  Adam Warski: Designing Programmer-Friendly APIs

https://simply-how.com/design-and-generate-api-code-from-openapi

https://news.ycombinator.com/item?id=18860799 . convert any database to REST API

https://www.graphile.org/postgraphile/ . PostGraphile

http://apievangelist.com/blog/

<h2>GraphQL</h2>
https://blog.graphqleditor.com/interactive-graphql-tutorial/
https://codeahoy.com/2019/10/13/graphql-practical-tutorial/
https://github.com/ian13456/modern-graphql-tutorial
https://blog.graphqleditor.com/is-graphql-future-of-api/
https://habr.com/ru/company/ruvds/blog/445268/
https://habr.com/company/jugru/blog/428517/ .  GraphQL
https://habr.com/ru/post/454604/ . GraphQL+React
https://verve.co/engineering/graphql-a-retrospective/


https://app.graphqleditor.com/?visibleMenu=code . Editor

https://nordicapis.com/rest-vs-graphql-how-constraints-determine-api-style/



https://blog.graphqleditor.com/top-3-python-libraries-for-graphql/
https://tartiflette.io/docs/tutorial/getting-started

<h2>API</h2>

https://habr.com/ru/post/476576/   REST vs RPC

https://www.imaginarycloud.com/blog/grpc-vs-rest/

https://apisyouwonthate.com/
https://blog.apisyouwonthate.com/
https://philsturgeon.uk/api/2018/03/01/api-specification-workflow-matures/
<a href=https://sites.google.com/a/athaydes.com/renato-athaydes/posts/thereturnofrpc-orhowrestisnolongertheonlyrespectablesolutionforapis>API evolution</a>
https://philsturgeon.uk/api/2018/05/02/api-evolution-for-rest-http-apis/

<h3> Swagger</h3>

https://swagger.io/
https://www.youtube.com/watch?v=JeaF0qnWqQY . Swagger (ru)
https://buildazure.com/2017/10/20/swagger-is-now-the-openapi-specification/
https://strongloop.com/strongblog/upgrade-from-swagger-to-openapi-3/

https://github.com/swagger-api/swagger-editor
https://blog.ippon.tech/using-swagger-to-build-effective-apis-pt1/
https://blog.ippon.tech/using-swagger-to-build-effective-apis-pt2/

 docker search swagger
 docker pull swaggerapi/swagger-editor
 docker run --rm -d -p 8083:8080 --name my-swagger-editor swaggerapi/swagger-editor &
 http://localhost:8083
 
In the docker command -v means to mount a volume and -e means to add environment variables, 
so what you want is probbably this:
docker run -p 8081:8080 -e SWAGGER_JSON=/mnt/lp.json -v /Users/abc/Desktop:/mnt swaggerapi/swagger-ui



https://www.asyncapi.com/
https://stdlib.com/
https://developers.redhat.com/blog/2018/04/11/api-journey-idea-deployment-agile-part1/
https://news.ycombinator.com/item?id=16952746

<h2> JSON-RPC</h2>
https://habr.com/post/429524/ .   
https://habr.com/ru/post/441854/

<h2>Microservices</h2>
https://habr.com/post/431474/ . 
https://github.com/mfornos/awesome-microservices
https://serverless.com/blog/how-create-rest-api-serverless-components/
https://www.youtube.com/watch?v=lwkDSOVKD7U   
https://www.packtpub.com//web-development/python-microservices-development?login=1 Book
https://caylent.com/microservices-good-bad-ugly/
https://www.youtube.com/watch?v=PFQnNFe27kU
https://codeburst.io/microservices-from-idea-to-starting-line-d6e8cd5e9bb4

https://itnext.io/from-monoliths-to-microservices-b6b851ab43e3

https://docs.microsoft.com/en-us/azure/architecture/microservices/api-design
https://itnext.io/microservices-the-event-sourcing-way-124a8a772680
https://www.ctheu.com/2017/01/18/how-to-communicate-between-micro-services-part-1/
https://www.ctheu.com/2017/01/22/how-to-communicate-between-micro-services-part-2-retryers/
https://www.ctheu.com/2017/01/29/how-to-communicate-between-micro-services-part-3-circuit-breakers/

https://medium.com/@ssola/building-microservices-with-python-part-i-5240a8dcc2fb#.89d66thpm
https://medium.com/@ssola/building-microservices-with-python-part-2-9f951199094a
https://medium.com/@ssola/building-microservices-with-python-part-3-a556a4c4bc00

 there are a lot of downsides to going with a normal HTTP/REST model.

Getting documentation working great is rough. At best, it usually involves some sort of Swagger middleware, 
which feels like stepping into early-2000s Java programming. It works, but its not great.

You still have to deal with things like pagination and limiting on your own,
even though often everyone ends up implementing the same solution. There are libraries that can help with this.

Once you get into complex querying, you inevitably start breaking out of REST paradigms. 
That might mean moving to get requests w/ bodies to support JSON without going into the URL query params,
or odata-like ugly query params, or duplicated endpoint logic just to mutate the data in a specific way the client needs. 
Every app of decent complexity gets to a point like this.

Many of those reasons are why RPC has become pretty popular recently.

I can't recommend gRPC. Its reliance on HTTP2 makes it very difficult to use in environments like AWS. 
I also dislike that it doesn't support querying with JSON, which means every client that tries to access it needs to support protobuf.
This makes it very difficult to use in internet-exposed applications. 
I've tried <b>Twirp</b> and I like it. I haven't tried Micro but it looks good.

All that said: I adore GraphQL. I truly believe GraphQL is the apex of internet-exposed API design.

You get documentation, schema enforcement, etc right out of the box.

Clients get to request the exact data that they need from your graph.
If I need a user, her name, email address, and the titles of every post she has liked,
I can fetch that in a single query with absolutely zero extra data over the wire.
A few other technologies have came out to support query patterns similar to this, but none are as clean as GraphQL. 
If you tried to implement that with more basic HTTP/RPC, you'd end up having a specific endpoint just for that query, 
ridiculously complex arguments, or sending too much data.

Though GraphQL still has a lot of problems:

Pagination is still an unsolved problem out of the box.

DDOSing a GraphQL server is pretty easy if it isn't designed to be resilient to it. 
Fortunately there's a lot of recent art out there you can reference for how to set it up to be resilient.

GraphQL with Go... sucks. It sucks a lot. And its completely because of the type system. Compared to Apollo and Vesper in JS, 
Absinthe in Elixir, and Juniper in Rust, Go is really far behind and shows no indication of catching up due to the limited type system

<h2>gRPC</h2>

https://www.programmableweb.com/news/how-to-build-streaming-api-using-grpc/how-to/2020/02/21
https://devopedia.org/grpc 
https://www.smoothterminal.com/articles/grpc-and-protocol-buffers-as-an-alternative-to-json-rest-apis
https://github.com/grpc-ecosystem
http://www.grpc.io/
https://medium.com/@shijuvar/building-high-performance-apis-in-go-using-grpc-and-protocol-buffers-2eda5b80771b

Unlike JSON and XML, Protocol Buffers are not just message interchange format, 
itâ€™s also used for describing the service interfaces (service endpoints). 
Thus Protocol Buffers are used for both the service interface and the structure of the payload messages. 

In gRPC, you define services and its methods along with payload messages. 
Like a typical communication between a client application and a RPC system, 
a gRPC client application can directly call methods on a remote server as if it was a local object in your client application.

https://habr.com/post/354706/  Twirp vs gRPC
https://grpc.io/docs/tutorials/basic/python.html
https://www.slideshare.net/InfoQ/generating-unified-apis-with-protocol-buffers-and-grpc
https://scotch.io/tutorials/implementing-remote-procedure-calls-with-grpc-and-protocol-buffers
https://blog.netsil.com/http-2-and-grpc-the-next-generation-of-microservices-interactions-aff4ffa6faed
https://blog.bugsnag.com/grpc-and-microservices-architecture/
https://blog.bugsnag.com/libraries-for-grpc-services/
https://blog.bugsnag.com/using-grpc-in-production/
https://github.com/grpc-ecosystem/awesome-grpc

<h2>protoBuff</h2>
https://developers.google.com/protocol-buffers/docs/pythontutorial
https://blog.wearewizards.io/using-protobuf-instead-of-json-to-communicate-with-a-frontend
https://www.callibrity.com/blog/protocol-buffers
https://github.com/uber/prototool
</pre>
